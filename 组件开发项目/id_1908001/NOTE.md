学习笔记
##第一周: 
###实现自动轮播
####实现方式
通过setTimeout定时改变当前图片和下一张图片的css样式(transition和transform)
通过css实现在轮播时有简单的动画
####总结
###手动拖拽切换图片
####实现方式
通过监听document的mousemove,mouseup事件, 改变当前图和下一张图的css样式
####总结
##第二周
###优化第一周的"手动拖拽切换图片", 抽象出手势库
####实现方式
先从手势库的角度出发, 不跟业务相关
1.实现一个手势库
2.在轮播图中引入手势库, 替换"手动拖拽切换图片"的代码
####总结
抽象并不是
##第三周
###优化第一周的"实现自动轮播"的动画部分, 抽象出动画库
####实现方式
先从动画库的角度出发, 不跟业务相关
1. 实现小球运动, 实现小球有不同的运动曲线, 实现暂停恢复, 实现rate
2. 实现小球颜色渐变
3. 在轮播图中引入动画库
难点: 插值函数---cubicBezier, Math.sin(progress * Math.PI / 2)
https://cubic-bezier.com/
####总结
不止实现功能, 需要达到尽可能的完美, 比如注重纯度和明度

## 9月7号线下大课
###组件设计
1. 添加attribute和property
2. 事件
   addEvent
   removeEvent
   triggerEvent
3. 生命周期
4. 状态
###改造轮播图为组件
###轮播图结合webpack
1. webpack实现能打包一个文件
   先npm install webpack -g  npm install webpack-cli -g
   建一个文件webpack.config.js, 里边配置上基本信息
   module.exports = {
       entry: './index.js',
       mode: "development",
       optimization: {
           minimize: false
       }
   }
2. 因为浏览器不能支持es6, 需要给webpack添加babel的loader
   npm install -D babel-loader @babel/core @babel/preset-env webpack
3. 将class转化为react的组件
   ① npm install babel-plugin-transform-react-jsx
   ② webpack中配置 plugins: [['babel-plugin-transform-react-jsx', {pragma:"myCreate"}]]
   module.exports = {
       entry: "./index.js",
       module: {
           rules: [
               {
                   test: /\.js$/,
                   use: {
                       loader: 'babel-loader',
                       options: {
                           presets: ['@babel/preset-env'],
                           plugins: [['babel-plugin-transform-react-jsx', {pragma:"myCreate"}]]
                       }
                   }
               }
           ]
       },
       mode: "development",
       optimization: {
           minimize: false
       }
   }
   ③ 创建myCreate函数, 用于将jsx翻译成class
##9月8号线下大课 
缓存: 把静态的资源和动态资源分开, 缓存静态资源
1. 304缓存
if-modified-since/last-modified
etag
2. manifest 缓存
###每日好店需求分析
###需求背景
为了帮助用户扩大购买范围, 同时增加商家更多的曝光机会, 需要开发一个区块用于展示被推荐的店铺和参与推广的店铺.
推荐店铺由后端人员通过分析用户画像去设计推荐算法, 推广店铺由运营平台录入. 
###需求列表
####1. "每日好店"入口 (跨线需求)  产品线: 手淘首页开发小组
   优先级: P0
   需求类型: 新需求
   需求列表: 
   1.在手淘首页添加一个入口, 点击后跳转到每日好店首页
####2. "每日好店"主体框架  产品线: 每日好店 项目组
   优先级: P0
   需求类型: 新需求
   需求列表: 
   1. "每日好店"整体页面由多个栏目组成(目前是四个), 分别为"推荐","有趣的店","品牌新店","发现" 
   2. 用户仅能看到一个栏目的内容, 栏目之间通过tab的方式进行切换
   3. 该页面支持分享和功能直达(native已支持)
####3. "每日好店"推荐
#####3.1 轮播图
#####3.2 超多人收藏的店
#####3.3 推荐店铺列表

###组件设计
####容器组件
1. tab
2. scroll
####页面
2. 推荐
3. 有趣的店
4. 品牌新店
####原子组件
1. 轮播组件
2. 店铺组件
   property: 店铺info----店铺id, 店铺头像, 店铺名称, 店铺等级, 关注人数, 店铺的tag
   event: 不喜欢
   子组件:
     商品组件
     推荐语组件: 关注人数, 店铺的tag
3. 商品组件
   property: 图片url...
4. 推荐语组件
   property: 关注人数, 店铺的tag
5. tag组件
###总结
####关于组件
一直用框架开发的程序员, 时间久了就会在这个舒适区里出不来, 尤其是对于我这种前端基础较差的人来说. 之前一直觉得框架的封装很有技术难度, 
这次老师讲的组件生命周期, 犹如醍醐灌顶, 再结合面向对象就朦朦胧胧的有了清晰感, 前端的组件=封装+继承+前端的钩子时机(被封装为方法),可能形容
的不太好, 以后想出来更好的表达再改这个公式. 所以用原生js写出来的组件, 经过合适的抽象,封装,继承之后就是react和vue等框架了, 当然每个框架的封装思路
会有不同的地方. 这就是第一天感觉收获最大的地方.
####关于如何封装组件
理解了组件之后, 另外一个重要的难点是如何抽取组件, 组件的抽取有n多种方式,各有优缺点, 但是一定有一种方式是最适合当前团队,当前业务,当前产品的方式,
对于淘宝的每日好店组件, 自己一开始分析组件的抽取时, 先考虑的是按照页面进行原子组件的抽取, 比如店铺组件,商品组件,tag组件, 然后是tab容器组件,
最后是页面, 比如整体的推荐页,有趣的店,品牌新店. 看了老师的拆分维度, 感觉自己的很初级... , 因为如果从淘宝的整个app角度出发, 下拉刷新和tab切换是几乎
每个页面都会用到的一种组件,可以抽取出来作为公用组件, 提高复用性, 尤其是scroll组件的抽取是之前没想到的维度.list组件之前考虑的时候觉得比较简单, 不需要
抽取, 放到页面中就行了, 但是如果考虑到上拉加载更多以及整个app的角度出发, 抽取也是很有复用性的. 
这个过程暴露了之前我对组件拆分维度的不足, 回来赶紧好好总结一下.
####关于进度
学习的这段时间, 赶紧自己可以跟上老师大方向思路的进度, 但是实现细节的思路和笔杆子跟不上, 比如轮播图组件的时候怎样去计算下一张图片的位置,动效之类的就跟不上,
比如线下课讲到去固定header的位置等就跟不上了, 我分析了原因, 是因为css基础不好, 原生js写的少导致的. 人在遇到未知领域的问题时总会发慌, 这是很自然的事情,
所以其实这并不可怕, 这个月能抽出一些时间补一下基础, 多练练笔杆子, 后续的课程还是有信心可以超越目前的状态.加油.





   





