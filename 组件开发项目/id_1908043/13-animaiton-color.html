<!-- 完成颜色变化 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        #ball {
            position:absolute;
            left: 0;
            top: 0;
            width:50px;
            height:50px;
            border-radius: 25px;
            background-color:skyblue;
        }
        .btn {
            margin-top: 100px;
        }
    </style>
</head>
<body>
    <div id="ball"></div>
    <div class="btn">
        <button id="pause">pause</button>
        <button id="resume">resume</button>
    </div>
    <script>
        function cubicBezier(p1x, p1y, p2x, p2y) {
            const ZERO_LIMIT = 1e-6;
            // Calculate the polynomial coefficients,
            // implicit first and last control points are (0,0) and (1,1).
            const ax = 3 * p1x - 3 * p2x + 1;
            const bx = 3 * p2x - 6 * p1x;
            const cx = 3 * p1x;

            const ay = 3 * p1y - 3 * p2y + 1;
            const by = 3 * p2y - 6 * p1y;
            const cy = 3 * p1y;

            function sampleCurveDerivativeX(t) {
                // `ax t^3 + bx t^2 + cx t' expanded using Horner 's rule.
                return (3 * ax * t + 2 * bx) * t + cx;
            }

            function sampleCurveX(t) {
                return ((ax * t + bx) * t + cx ) * t;
            }

            function sampleCurveY(t) {
                return ((ay * t + by) * t + cy ) * t;
            }

            // Given an x value, find a parametric value it came from.
            function solveCurveX(x) {
                var t2 = x;
                var derivative;
                var x2;

                // https://trac.webkit.org/browser/trunk/Source/WebCore/platform/animation
                // First try a few iterations of Newton's method -- normally very fast.
                // http://en.wikipedia.org/wiki/Newton's_method
                for (let i = 0; i < 8; i++) {
                    // f(t)-x=0
                    x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < ZERO_LIMIT) {
                        return t2;
                    }
                    derivative = sampleCurveDerivativeX(t2);
                    // == 0, failure
                    /* istanbul ignore if */
                    if (Math.abs(derivative) < ZERO_LIMIT) {
                        break;
                    }
                    t2 -= x2 / derivative;
                }

                // Fall back to the bisection method for reliability.
                // bisection
                // http://en.wikipedia.org/wiki/Bisection_method
                var t1 = 1;
                /* istanbul ignore next */
                var t0 = 0;

                /* istanbul ignore next */
                t2 = x;
                /* istanbul ignore next */
                while (t1 > t0) {
                    x2 = sampleCurveX(t2) - x;
                    if (Math.abs(x2) < ZERO_LIMIT) {
                        return t2;
                    }
                    if (x2 > 0) {
                        t1 = t2;
                    } else {
                        t0 = t2;
                    }
                    t2 = (t1 + t0) / 2;
                }

                // Failure
                return t2;
            }

            function solve(x) {
                return sampleCurveY(solveCurveX(x));
            }

            return solve;
        }

        let linear = cubicBezier(0, 0, 1, 1);
        let ease = cubicBezier(.25, .1, .25, 1);
        let easeIn = cubicBezier(.42, 0, 1, 1);
        let easeOut = cubicBezier(0, 0, .58, 1);
        let easeInOut = cubicBezier(.42, 0, .58, 1);
        let myCB = cubicBezier(.69,-0.85,.25,1);

        class TimeLine {
            constructor() {
                this._animations = []
                this._timer = null;
                this._tick = null;
                this._pauseStart = 0;
                this._pauseTime = 0;
                // 绑定方法 this 到对象
                this.pause = this.pause.bind(this)
                this.resume = this.resume.bind(this)
                // 状态管理
                this._status = 'init' // init, pause, start
                // 速率
                this._rate = 1
                this._startTime = 0
            }
            start() {
                if (this._status === 'start') return
                this._status = 'start';
                const startTime = Date.now()
                // 这里给_tick赋值时，会保存 startTime 的值
                this._tick = () => {
                    for (let animation of this._animations) {
                        animation.tick((Date.now() - startTime - this._pauseTime) * this._rate + this._startTime)
                    }
                    // this._timer = setTimeout(this._tick, 16)
                    if (this._timer) this._timer = requestAnimationFrame(this._tick)

                }
                // this._timer = setInterval(this._tick, 16) // 方式 1，定时器
                // this._timer = setTimeout(this._tick, 16) // 方式 2，延时器
                this._timer = requestAnimationFrame(this._tick) // 方式 3
            }
            pause() {
                if (this._status !== 'start') return
                this._status = 'pause'
                // clearInterval(this._timer)
                this._pauseStart = Date.now()
                clearTimeout(this._timer)
                this._timer = null
            }
            resume() {
                if (this._status !== 'pause') return
                this._status = 'start'
                this._pauseTime = Date.now() - this._pauseStart
                // this._timer = setInterval(this._tick, 16)
                // this._timer = setTimeout(this._tick, 16)
                this._timer = requestAnimationFrame(this._tick)
            }
            set rate(value) {
                this._rate = value
            }
            get rate() {
                return this._rate
            }
            set startTime(value) {
                this._startTime = value
            }
            get startTime() {
                return this._startTime
            }
            addAnimation(animation) {
                this._animations.push(animation)
            }
            removeAnimation() {}
        }

        class DOMElementStyleAnimation {
            constructor(element, property, startTime, startValue, endTime, endValue, converter) {
                this._element = element;
                this._property = property;
                this._startTime = startTime;
                this._startValue = startValue;
                this._endTime = endTime;
                this._endValue = endValue;
                this._converter = converter;
            }

            tick(t) {
                if(t < this._startTime) return;
                if(t > this._endTime) {
                    this._element.style[this._property] = this._endValue
                    return;
                }
                // 线性插值
                let progress = (t - this._startTime) / (this._endTime - this._startTime)
                let displacement = ease(progress) * (this._endValue - this._startValue)
                let current = displacement +  this._startValue

                // console.log((t - this._startTime) / (this._endTime - this._startTime) * (this._endValue - this._startValue) + this._startValue)
                this._element.style[this._property] = this._converter(current)
            }
        }

        class DOMElementColorAnimation {
            constructor(element, property, startTime, startValue, endTime, endValue, converter) {
                this._element = element;
                this._property = property;
                this._startTime = startTime;
                this._startValue = startValue;
                this._endTime = endTime;
                this._endValue = endValue;
                this._converter = converter;
            }

            tick(t) {
                if(t < this._startTime) return;
                if(t > this._endTime) {
                    this._element.style[this._property] = this._endValue
                    return;
                }
                let displacement = []
                let current = []
                let progress = (t - this._startTime) / (this._endTime - this._startTime)

                for(let i = 0; i < this._endValue.length; i++) {
                    displacement[i] = ease(progress) * (this._endValue[i] - this._startValue[i])
                    current[i] = displacement[i] + this._startValue[i]
                }
                this._element.style[this._property] = this._converter(current)
            }
        }

        const tl = new TimeLine()
        tl.addAnimation(new DOMElementStyleAnimation(
            document.getElementById('ball'),
            'top',
            0, 0,
            500, 100,
            v => `${v}px`
        ))
        tl.addAnimation(new DOMElementColorAnimation(
            document.getElementById('ball'),
            'backgroundColor',
            0, [255, 0, 0],
            500, [0, 255, 0],
            v => `rgb(${v[0]},${v[1]},${v[2]})`
        ))
        tl.addAnimation(new DOMElementStyleAnimation(
            document.getElementById('ball'),
            'left',
            500, 0,
            1000, 100,
            v => `${v}px`
        ))
        tl.addAnimation(new DOMElementStyleAnimation(
            document.getElementById("ball"),
            'top',
            1000, 100,
            1500, 0,
            v => `${v}px`
        ));
        tl.addAnimation(new DOMElementStyleAnimation(
            document.getElementById("ball"),
            'left',
            1500, 100,
            2000, 0,
            v => `${v}px`
        ));

        // tl.rate = 2 // 2倍速
        // tl.rate = -1 // -1倍速
        // tl.startTime = 2000
        tl.start();

        document.getElementById('pause').addEventListener('click', tl.pause)
        document.getElementById('resume').addEventListener('click', tl.resume)

    </script>
</body>
</html>